<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdaptLight</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #e0f2fe;
            color: #1e293b;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #0f172a;
        }
        .light-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
        }
        .light-display {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: rgb(0, 0, 0);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
            transition: background 0.3s, box-shadow 0.3s;
        }
        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .main-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(145deg, #f1f5f9, #cbd5e1);
            box-shadow: 5px 5px 15px rgba(0,0,0,0.1), -5px -5px 15px rgba(255,255,255,0.8);
            cursor: pointer;
            transition: all 0.1s;
            font-size: 12px;
            color: #64748b;
            font-weight: 500;
        }
        .main-button:active {
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1), inset -2px -2px 5px rgba(255,255,255,0.8);
        }
        .button-hint {
            font-size: 11px;
            color: #94a3b8;
            text-align: center;
        }
        .state-info {
            text-align: center;
            margin-bottom: 30px;
            font-size: 14px;
            color: #64748b;
        }
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            background: #fff;
            color: #1e293b;
            font-size: 16px;
        }
        input[type="text"]:focus {
            outline: 2px solid #0ea5e9;
            border-color: transparent;
        }
        input[type="text"]::placeholder {
            color: #94a3b8;
        }
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            background: #0ea5e9;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #0284c7;
        }
        button:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
        }
        .reset-btn {
            background: #f1f5f9;
            color: #64748b;
            border: 1px solid #cbd5e1;
        }
        .reset-btn:hover {
            background: #e2e8f0;
        }
        .action-bar {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .vision-controls {
            background: #fff;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .vision-preview {
            width: 220px;
            height: 165px;
            border-radius: 8px;
            border: 1px solid #cbd5e1;
            object-fit: cover;
            background: #0f172a;
            display: none;
        }
        .vision-status {
            font-size: 12px;
            color: #64748b;
        }
        .vision-debug {
            width: 100%;
            font-size: 12px;
            color: #475569;
            line-height: 1.4;
        }
        .vision-btn {
            padding: 8px 14px;
            font-size: 13px;
        }
        .response {
            background: #fff;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            min-height: 60px;
            border: 1px solid #e2e8f0;
        }
        .response.error {
            border-left: 4px solid #ef4444;
        }
        .response.success {
            border-left: 4px solid #22c55e;
        }
        .timing {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 8px;
        }
        .tools {
            font-size: 12px;
            color: #94a3b8;
            margin-top: 8px;
        }
        .loading {
            text-align: center;
            color: #94a3b8;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .loading span {
            animation: pulse 1s infinite;
        }
        .gesture-indicator {
            font-size: 12px;
            color: #0ea5e9;
            height: 18px;
            margin-top: 5px;
        }
        .details-panel {
            background: #fff;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
            overflow: hidden;
        }
        .details-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            user-select: none;
        }
        .details-header:hover {
            background: #f1f5f9;
        }
        .details-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #475569;
            margin: 0;
        }
        .details-toggle {
            font-size: 12px;
            color: #94a3b8;
        }
        .details-content {
            padding: 16px;
            display: none;
        }
        .details-content.open {
            display: block;
        }
        .details-section {
            margin-bottom: 16px;
        }
        .details-section:last-child {
            margin-bottom: 0;
        }
        .details-section h4 {
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .state-item, .rule-item {
            background: #f8fafc;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 13px;
            font-family: 'SF Mono', Monaco, monospace;
        }
        .state-item.current {
            background: #dbeafe;
            border: 1px solid #93c5fd;
        }
        .state-name {
            font-weight: 600;
            color: #1e293b;
        }
        .state-color {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 6px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .state-params {
            color: #64748b;
            font-size: 11px;
            margin-top: 4px;
        }
        .rule-arrow {
            color: #94a3b8;
        }
        .rule-trigger {
            color: #0ea5e9;
            font-weight: 500;
        }
        .rule-condition {
            color: #8b5cf6;
            font-size: 11px;
            margin-top: 4px;
        }
        .empty-message {
            color: #94a3b8;
            font-style: italic;
            font-size: 13px;
        }
        /* Agent Steps Panel */
        .agent-steps-panel {
            background: #fff;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
            overflow: hidden;
        }
        .agent-steps-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #fef3c7;
            border-bottom: 1px solid #fcd34d;
            cursor: pointer;
            user-select: none;
        }
        .agent-steps-header:hover {
            background: #fde68a;
        }
        .agent-steps-header h3 {
            font-size: 14px;
            font-weight: 600;
            color: #92400e;
            margin: 0;
        }
        .agent-steps-toggle {
            font-size: 12px;
            color: #b45309;
        }
        .agent-steps-content {
            padding: 16px;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        .agent-steps-content.open {
            display: block;
        }
        .agent-step {
            background: #f8fafc;
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 13px;
            border-left: 3px solid #cbd5e1;
        }
        .agent-step:last-child {
            margin-bottom: 0;
        }
        .agent-step.thinking {
            border-left-color: #8b5cf6;
            background: #faf5ff;
        }
        .agent-step.tool_call {
            border-left-color: #0ea5e9;
            background: #f0f9ff;
        }
        .agent-step.tool_result {
            border-left-color: #22c55e;
            background: #f0fdf4;
        }
        .agent-step.api_timing {
            border-left-color: #f59e0b;
            background: #fffbeb;
        }
        .agent-step.done {
            border-left-color: #10b981;
            background: #ecfdf5;
        }
        .step-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .step-icon {
            font-size: 14px;
        }
        .step-turn {
            font-size: 10px;
            font-weight: 600;
            background: #e2e8f0;
            color: #475569;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .step-type {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .step-type.thinking { color: #7c3aed; }
        .step-type.tool_call { color: #0284c7; }
        .step-type.tool_result { color: #16a34a; }
        .step-type.api_timing { color: #d97706; }
        .step-type.done { color: #059669; }
        .step-timing {
            font-size: 11px;
            color: #94a3b8;
            margin-left: auto;
        }
        .step-content {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            color: #334155;
            white-space: pre-wrap;
            word-break: break-word;
            background: rgba(0,0,0,0.03);
            padding: 8px;
            border-radius: 4px;
            max-height: 150px;
            overflow-y: auto;
        }
        .step-tool-name {
            font-weight: 600;
            color: #1e293b;
        }
        /* User ID Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal {
            background: #fff;
            border-radius: 12px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .modal h2 {
            margin: 0 0 8px 0;
            color: #0f172a;
            font-size: 24px;
        }
        .modal p {
            color: #64748b;
            margin: 0 0 24px 0;
            font-size: 14px;
        }
        .modal input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 16px;
            transition: border-color 0.2s;
        }
        .modal input:focus {
            outline: none;
            border-color: #0ea5e9;
        }
        .modal button {
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
        }
        .modal button:disabled {
            background: #cbd5e1;
        }
        /* User badge */
        .user-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 20px;
            font-size: 13px;
            color: #0369a1;
        }
        .user-badge .user-icon {
            font-size: 16px;
        }
        .user-badge .change-user {
            margin-left: 8px;
            color: #0ea5e9;
            cursor: pointer;
            font-size: 12px;
        }
        .user-badge .change-user:hover {
            text-decoration: underline;
        }
        /* Feedback Box */
        .feedback-box {
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
            padding: 16px;
            margin-top: 16px;
        }
        .feedback-box.hidden {
            display: none;
        }
        .feedback-box.submitted {
            background: #f0fdf4;
            border-color: #86efac;
        }
        .feedback-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .feedback-header h4 {
            font-size: 13px;
            font-weight: 600;
            color: #92400e;
            margin: 0;
        }
        .feedback-box.submitted .feedback-header h4 {
            color: #166534;
        }
        .feedback-close {
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            line-height: 1;
        }
        .feedback-close:hover {
            color: #64748b;
            background: none;
        }
        .feedback-textarea {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            min-height: 60px;
            margin-bottom: 12px;
        }
        .feedback-textarea:focus {
            outline: 2px solid #f59e0b;
            border-color: transparent;
        }
        .feedback-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .feedback-submit {
            background: #f59e0b;
            padding: 8px 16px;
            font-size: 14px;
        }
        .feedback-submit:hover {
            background: #d97706;
        }
        .feedback-submit:disabled {
            background: #cbd5e1;
        }
        .feedback-success {
            color: #166534;
            font-size: 14px;
        }
        /* Project Description */
        .project-description {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }
        .project-description p {
            color: #0369a1;
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }
        /* Quick Feedback Buttons */
        .quick-feedback {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #e2e8f0;
        }
        .quick-feedback-label {
            font-size: 13px;
            color: #64748b;
        }
        .feedback-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid #e2e8f0;
            background: #fff;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            padding: 0;
        }
        .feedback-btn:hover:not(:disabled) {
            transform: scale(1.1);
        }
        .feedback-btn.good {
            color: #22c55e;
        }
        .feedback-btn.good:hover:not(:disabled) {
            border-color: #22c55e;
            background: #f0fdf4;
        }
        .feedback-btn.bad {
            color: #ef4444;
        }
        .feedback-btn.bad:hover:not(:disabled) {
            border-color: #ef4444;
            background: #fef2f2;
        }
        .feedback-btn.selected {
            transform: scale(1.1);
        }
        .feedback-btn.good.selected {
            border-color: #22c55e;
            background: #22c55e;
            color: #fff;
        }
        .feedback-btn.bad.selected {
            border-color: #ef4444;
            background: #ef4444;
            color: #fff;
        }
        .feedback-btn:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        .feedback-submitted-msg {
            font-size: 12px;
            color: #64748b;
            margin-left: 8px;
        }
        .top-nav {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        .top-nav a {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 12px 24px;
            border-radius: 8px;
            background: #0f172a;
            color: #fff;
            text-decoration: none;
            font-size: 16px;
            font-weight: 500;
        }
    </style>
    <script src="/static/expression.js"></script>
</head>
<body>
    <!-- User ID Modal -->
    <div class="modal-overlay" id="userModal" style="display: none;">
        <div class="modal">
            <h2>Welcome to AdaptLight</h2>
            <p>Please enter your name or ID to get started. This helps us track your session.</p>
            <input type="text" id="userIdInput" placeholder="Enter your name or ID..." autocomplete="off">
            <button id="userIdSubmit" onclick="submitUserId()" disabled>Continue</button>
        </div>
    </div>

    <div class="container">
        <h1>AdaptLight</h1>

        <div class="top-nav">
            <a href="/eval">Go to Eval</a>
        </div>

        <!-- User Badge -->
        <div class="user-badge" id="userBadge" style="display: none;">
            <span class="user-icon">ðŸ‘¤</span>
            <span id="userDisplayName"></span>
            <span class="change-user" onclick="changeUser()">change</span>
        </div>

        <div class="light-container">
            <div class="light-display" id="light"></div>
            <div class="button-container">
                <button class="main-button" id="mainButton">PRESS</button>
                <div class="button-hint">click Â· double Â· hold</div>
                <div class="gesture-indicator" id="gestureIndicator"></div>
            </div>
        </div>

        <div class="state-info" id="stateInfo">
            State: <span id="stateName">off</span>
        </div>

        <div class="project-description">
            <p>This is a light bulb simulator that simulates an adaptive light that takes voice comments and inputs. Originally, the light starts with on/off - the light will turn on/off with a simple click. As you type into the comment, it will change functions and control what the button does. You can be as creative as you want.</p>
        </div>

        <div class="input-group">
            <input type="text" id="commandInput" placeholder="Enter a command...">
            <button id="sendBtn" onclick="sendCommand()">Send</button>
        </div>

        <div class="action-bar">
            <button class="reset-btn" onclick="resetSM()">Reset</button>
        </div>

        <div class="vision-controls" id="visionControls">
            <button class="vision-btn" id="visionStartBtn" onclick="startCameraVision()">Start Camera Vision</button>
            <button class="vision-btn reset-btn" id="visionStopBtn" onclick="stopCameraVision()" disabled>Stop Camera Vision</button>
            <span class="vision-status" id="visionStatus">Vision idle</span>
            <video id="visionVideo" class="vision-preview" autoplay playsinline muted></video>
            <canvas id="visionCanvas" width="320" height="240" style="display:none;"></canvas>
            <div class="vision-debug" id="visionDebugLabel">Vision State: idle</div>
            <div class="vision-debug" id="visionDebugEngine">Engine: -</div>
            <div class="vision-debug" id="visionDebugCountdown">Next capture in: -</div>
            <div class="vision-debug" id="visionDebugDescription">Description: -</div>
            <div class="vision-debug" id="visionDebugData">Data: -</div>
            <div class="vision-debug" id="visionDebugTiming">Timing: -</div>
        </div>

        <div class="response" id="response">
            <div class="loading" id="loading" style="display: none;">
                <span>Processing...</span>
            </div>
            <div id="responseText">Ready to receive commands.</div>
            <div class="timing" id="timing"></div>
            <div class="tools" id="tools"></div>

            <!-- Quick Feedback Buttons -->
            <div class="quick-feedback" id="quickFeedback" style="display: none;">
                <span class="quick-feedback-label">Did it work?</span>
                <button class="feedback-btn good" id="feedbackGood" onclick="submitQuickFeedback(true)">âœ“</button>
                <button class="feedback-btn bad" id="feedbackBad" onclick="submitQuickFeedback(false)">âœ—</button>
                <span class="feedback-submitted-msg" id="feedbackSubmittedMsg" style="display: none;">Thanks!</span>
            </div>

            <!-- Feedback Box (appears after command) -->
            <div class="feedback-box hidden" id="feedbackBox">
                <div class="feedback-header">
                    <h4 id="feedbackTitle">Not what you expected? Leave feedback:</h4>
                    <button class="feedback-close" onclick="closeFeedback()">&times;</button>
                </div>
                <textarea class="feedback-textarea" id="feedbackText" placeholder="Describe what went wrong or what you expected..."></textarea>
                <div class="feedback-actions">
                    <button class="feedback-submit" id="feedbackSubmit" onclick="submitFeedback()">Submit Feedback</button>
                    <span class="feedback-success hidden" id="feedbackSuccess">Thanks for your feedback!</span>
                </div>
            </div>
        </div>

        <div class="agent-steps-panel" id="agentStepsPanel" style="display: none;">
            <div class="agent-steps-header" onclick="toggleAgentSteps()">
                <h3>Agent Steps <span id="agentStepsCount"></span></h3>
                <span class="agent-steps-toggle" id="agentStepsToggle">â–¼ Show</span>
            </div>
            <div class="agent-steps-content" id="agentStepsContent">
                <div id="agentStepsList"></div>
            </div>
        </div>

        <div class="details-panel">
            <div class="details-header" onclick="toggleDetails()">
                <h3>States & Rules</h3>
                <span class="details-toggle" id="detailsToggle">â–¼ Show</span>
            </div>
            <div class="details-content" id="detailsContent">
                <div class="details-section">
                    <h4>States</h4>
                    <div id="statesList">
                        <div class="empty-message">No custom states defined</div>
                    </div>
                </div>
                <div class="details-section">
                    <h4>Rules</h4>
                    <div id="rulesList">
                        <div class="empty-message">No rules defined</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('=== MAIN PAGE LOADED (v2 with polling) ===');
        const lightEl = document.getElementById('light');
        const stateNameEl = document.getElementById('stateName');
        const responseEl = document.getElementById('response');
        const responseTextEl = document.getElementById('responseText');
        const timingEl = document.getElementById('timing');
        const toolsEl = document.getElementById('tools');
        const loadingEl = document.getElementById('loading');
        const inputEl = document.getElementById('commandInput');
        const sendBtn = document.getElementById('sendBtn');
        const mainButton = document.getElementById('mainButton');
        const gestureIndicator = document.getElementById('gestureIndicator');
        const visionControls = document.getElementById('visionControls');
        const visionStartBtn = document.getElementById('visionStartBtn');
        const visionStopBtn = document.getElementById('visionStopBtn');
        const visionStatus = document.getElementById('visionStatus');
        const visionVideo = document.getElementById('visionVideo');
        const visionCanvas = document.getElementById('visionCanvas');
        const visionDebugLabel = document.getElementById('visionDebugLabel');
        const visionDebugEngine = document.getElementById('visionDebugEngine');
        const visionDebugCountdown = document.getElementById('visionDebugCountdown');
        const visionDebugDescription = document.getElementById('visionDebugDescription');
        const visionDebugData = document.getElementById('visionDebugData');
        const visionDebugTiming = document.getElementById('visionDebugTiming');

        // User identification
        const userModal = document.getElementById('userModal');
        const userIdInput = document.getElementById('userIdInput');
        const userIdSubmit = document.getElementById('userIdSubmit');
        const userBadge = document.getElementById('userBadge');
        const userDisplayName = document.getElementById('userDisplayName');
        let currentUserId = null;

        // Check for existing user on load
        function initUser() {
            const savedUserId = localStorage.getItem('adaptlight_user_id');
            if (savedUserId) {
                currentUserId = savedUserId;
                showUserBadge();
            } else {
                showUserModal();
            }
        }

        function showUserModal() {
            userModal.style.display = 'flex';
            userBadge.style.display = 'none';
            userIdInput.value = '';
            userIdInput.focus();
        }

        function showUserBadge() {
            userModal.style.display = 'none';
            userBadge.style.display = 'flex';
            userDisplayName.textContent = currentUserId;
        }

        function submitUserId() {
            const userId = userIdInput.value.trim();
            if (userId) {
                currentUserId = userId;
                localStorage.setItem('adaptlight_user_id', userId);
                showUserBadge();
            }
        }

        function changeUser() {
            showUserModal();
        }

        // Enable submit button when input has value
        userIdInput.addEventListener('input', () => {
            userIdSubmit.disabled = !userIdInput.value.trim();
        });

        // Submit on Enter
        userIdInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && userIdInput.value.trim()) {
                submitUserId();
            }
        });

        // Initialize user on page load
        initUser();

        // Gesture detection state
        let pressStartTime = 0;
        let clickCount = 0;
        let clickTimer = null;
        let holdTimer = null;
        let isHolding = false;

        const HOLD_THRESHOLD = 500;      // ms to trigger hold
        const DOUBLE_CLICK_WINDOW = 300; // ms window for double click

        // Animation state
        let animationId = null;
        let animationFrame = 0;
        let animationStartTime = 0;
        let currentState = null;
        let currentColor = { r: 0, g: 0, b: 0 };
        let visionConfig = { enabled: false, mode: 'polling', interval_ms: 2000 };
        let audioConfig = { enabled: true, model: 'gpt-4o-mini', interval_ms: 3000, allow_fallback_transcript: false };
        let volumeConfig = { enabled: true, interval_ms: 80, smoothing_alpha: 0.35, floor: 0.0, ceiling: 1.0 };
        let visionSessionId = null;
        let visionStream = null;
        let micStream = null;
        let micAudioContext = null;
        let micAnalyser = null;
        let micDataArray = null;
        let micSourceNode = null;
        let micRecognition = null;
        let audioSessionId = null;
        let volumeSessionId = null;
        let audioListenerRunning = false;
        let volumeListenerRunning = false;
        let audioChunkParts = [];
        let audioChunkStartedAtMs = 0;
        let audioLastSentAtMs = 0;
        let audioSpeechActive = false;
        let volumeLoopId = null;
        let audioLoopId = null;
        let latestMicLevel = 0;
        let visionLoopId = null;
        let visionFrameInFlight = false;
        let visionDroppedFrames = 0;
        let visionNextCaptureAtMs = 0;
        let visionLoopIntervalMs = 2000;
        let visionCountdownId = null;
        let visionHasActiveWatchers = false;  // Track if current state has vision watchers
        const VISION_IDLE_CHECK_MS = 1000;    // Check for watchers every 1s when idle
        let lastVlmStateText = 'Vision State: idle';
        let lastVlmEngineText = 'Engine: -';
        let lastVlmDescriptionText = 'Description: -';
        let lastVlmDataText = 'Data: -';
        let lastVlmTimingText = 'Timing: -';
        const sharedStateData = {};
        const VISION_SEND_MAX_WIDTH = 320;  // Smaller = faster CV processing
        ExpressionEvaluator.setDataStore(sharedStateData);

        function setVisionDebug({ state = 'Vision State: idle', engine = 'Engine: -', countdown = null, description = 'Description: -', data = 'Data: -', timing = 'Timing: -' } = {}) {
            if (visionDebugLabel) visionDebugLabel.textContent = state;
            if (visionDebugEngine) visionDebugEngine.textContent = engine;
            if (visionDebugCountdown && countdown !== null) visionDebugCountdown.textContent = countdown;
            if (visionDebugDescription) visionDebugDescription.textContent = description;
            if (visionDebugData) visionDebugData.textContent = data;
            if (visionDebugTiming) visionDebugTiming.textContent = timing;
        }

        function rememberLatestVlm({ state, engine, description, data, timing } = {}) {
            if (state) lastVlmStateText = state;
            if (engine) lastVlmEngineText = engine;
            if (description) lastVlmDescriptionText = description;
            if (data) lastVlmDataText = data;
            if (timing) lastVlmTimingText = timing;
        }

        function formatVisionValue(value) {
            if (value === null || value === undefined) return '-';
            if (typeof value === 'number') {
                if (!Number.isFinite(value)) return String(value);
                return Number.isInteger(value) ? String(value) : value.toFixed(2);
            }
            if (typeof value === 'object') {
                try {
                    return JSON.stringify(value);
                } catch (e) {
                    return '[object]';
                }
            }
            return String(value);
        }

        function applyMappedDataToStore(mappedData) {
            if (!Array.isArray(mappedData)) return;
            for (const item of mappedData) {
                if (!item || typeof item.key !== 'string' || item.key.length === 0) continue;
                sharedStateData[item.key] = item.value;
            }
        }

        function hydrateStateDataFromState(state) {
            if (!state || typeof state !== 'object') return;
            const candidates = [state.state_data, state.data, state.context_data];
            for (const source of candidates) {
                if (!source || typeof source !== 'object') continue;
                Object.assign(sharedStateData, source);
            }
        }

        function stopVisionCountdownTicker() {
            if (visionCountdownId) {
                clearInterval(visionCountdownId);
                visionCountdownId = null;
            }
        }

        function startVisionCountdownTicker() {
            stopVisionCountdownTicker();
            visionCountdownId = setInterval(() => {
                if (!visionSessionId || !visionNextCaptureAtMs || visionFrameInFlight) {
                    return;
                }

                const remainingMs = Math.max(0, visionNextCaptureAtMs - Date.now());
                const remainingSec = Math.ceil(remainingMs / 1000);
                if (visionDebugCountdown) {
                    visionDebugCountdown.textContent = `Next capture in: ${remainingSec}s`;
                }
            }, 200);
        }

        function scheduleVisionLoop(delayMs = 0) {
            if (!visionSessionId) return;
            if (visionLoopId) {
                clearTimeout(visionLoopId);
                visionLoopId = null;
            }
            visionNextCaptureAtMs = Date.now() + Math.max(0, delayMs);
            if (visionDebugCountdown) {
                if (delayMs <= 0) {
                    visionDebugCountdown.textContent = 'Next capture in: now';
                } else {
                    visionDebugCountdown.textContent = `Next capture in: ${Math.ceil(delayMs / 1000)}s`;
                }
            }
            startVisionCountdownTicker();
            visionLoopId = setTimeout(async () => {
                // Check for active watchers before capturing
                if (!visionHasActiveWatchers) {
                    // No active watchers - just check status and reschedule
                    try {
                        const statusRes = await fetch(`/api/vision/status?session_id=${visionSessionId}`);
                        const statusData = await statusRes.json();
                        visionHasActiveWatchers = statusData.has_active_watchers || false;
                        if (visionHasActiveWatchers) {
                            console.log('[vision] Watchers now active, resuming capture');
                            setVisionDebug({ state: 'Vision State: resuming', countdown: 'Next capture in: now' });
                        } else {
                            setVisionDebug({ state: 'Vision State: idle (no watchers)', countdown: `Checking in: ${VISION_IDLE_CHECK_MS/1000}s` });
                        }
                    } catch (e) {
                        console.log('[vision] Status check failed:', e);
                    }
                    scheduleVisionLoop(visionHasActiveWatchers ? 0 : VISION_IDLE_CHECK_MS);
                    return;
                }

                if (visionDebugCountdown) {
                    visionDebugCountdown.textContent = 'Next capture in: capturing now';
                }
                await sendVisionFrame();
                const loopMs = Math.max(1000, Number(visionLoopIntervalMs || visionConfig.interval_ms || 2000));
                scheduleVisionLoop(loopMs);
            }, Math.max(0, delayMs));
        }

        function updateVisionLoopIntervalFromWatchers(watchers) {
            // Track if we have active watchers
            visionHasActiveWatchers = Array.isArray(watchers) && watchers.length > 0;

            if (!visionHasActiveWatchers) {
                visionLoopIntervalMs = Math.max(1000, Number(visionConfig.interval_ms || 2000));
                console.log('[vision] No active watchers, will idle');
                return;
            }

            const intervals = watchers
                .map(w => Number(w.effective_interval_ms || w.interval_ms || 0))
                .filter(v => Number.isFinite(v) && v > 0);

            if (intervals.length === 0) {
                visionLoopIntervalMs = Math.max(1000, Number(visionConfig.interval_ms || 2000));
                return;
            }

            visionLoopIntervalMs = Math.max(1000, Math.min(...intervals));
        }

        // Polling for timer-triggered state changes
        let statePollingId = null;
        let lastStateName = null;

        function startStatePolling() {
            // Poll every 500ms for state changes (timers, etc.)
            if (statePollingId) return; // Already polling

            console.log('Starting state polling...');
            statePollingId = setInterval(async () => {
                try {
                    const res = await fetch('/api/state');
                    const data = await res.json();
                    if (data.success && data.state) {
                        // Only update if state changed
                        if (data.state.name !== lastStateName) {
                            console.log(`State changed: ${lastStateName} â†’ ${data.state.name}`);
                            lastStateName = data.state.name;
                            updateLight(data.state);
                            if (detailsOpen) fetchDetails();
                        }
                    }
                } catch (e) {
                    console.error('Polling error:', e);
                }
            }, 500);
        }

        function stopStatePolling() {
            if (statePollingId) {
                clearInterval(statePollingId);
                statePollingId = null;
            }
        }

        // Details panel state
        let detailsOpen = false;

        // Agent steps panel state
        let agentStepsOpen = false;
        const agentStepsPanel = document.getElementById('agentStepsPanel');
        const agentStepsContent = document.getElementById('agentStepsContent');
        const agentStepsToggle = document.getElementById('agentStepsToggle');
        const agentStepsList = document.getElementById('agentStepsList');
        const agentStepsCount = document.getElementById('agentStepsCount');

        // Feedback state
        let currentSessionId = null;
        const feedbackBox = document.getElementById('feedbackBox');
        const feedbackText = document.getElementById('feedbackText');
        const feedbackSubmit = document.getElementById('feedbackSubmit');
        const feedbackSuccess = document.getElementById('feedbackSuccess');
        const feedbackTitle = document.getElementById('feedbackTitle');


        function showFeedback(sessionId) {
            currentSessionId = sessionId;
            feedbackBox.classList.remove('hidden', 'submitted');
            feedbackText.value = '';
            feedbackText.disabled = false;
            feedbackSubmit.disabled = false;
            feedbackSubmit.style.display = 'inline-block';
            feedbackSuccess.classList.add('hidden');
            feedbackTitle.textContent = 'Not what you expected? Leave feedback:';
        }

        function closeFeedback() {
            feedbackBox.classList.add('hidden');
            currentSessionId = null;
        }

        async function submitFeedback() {
            const feedback = feedbackText.value.trim();
            if (!feedback || !currentSessionId) return;

            feedbackSubmit.disabled = true;

            try {
                const res = await fetch('/api/feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        feedback: feedback
                    })
                });
                const data = await res.json();

                if (data.success) {
                    feedbackBox.classList.add('submitted');
                    feedbackTitle.textContent = 'Feedback submitted';
                    feedbackText.disabled = true;
                    feedbackSubmit.style.display = 'none';
                    feedbackSuccess.classList.remove('hidden');
                }
            } catch (e) {
                console.error('Failed to submit feedback:', e);
                feedbackSubmit.disabled = false;
            }
        }

        // Button event handlers
        mainButton.addEventListener('mousedown', handlePressStart);
        mainButton.addEventListener('mouseup', handlePressEnd);
        mainButton.addEventListener('mouseleave', handlePressEnd);
        mainButton.addEventListener('touchstart', (e) => { e.preventDefault(); handlePressStart(); });
        mainButton.addEventListener('touchend', (e) => { e.preventDefault(); handlePressEnd(); });

        function handlePressStart() {
            pressStartTime = Date.now();
            isHolding = false;

            // Start hold timer
            holdTimer = setTimeout(() => {
                isHolding = true;
                gestureIndicator.textContent = 'hold';
                trigger('button_hold');
            }, HOLD_THRESHOLD);
        }

        function handlePressEnd() {
            const pressDuration = Date.now() - pressStartTime;

            // Clear hold timer
            if (holdTimer) {
                clearTimeout(holdTimer);
                holdTimer = null;
            }

            // If it was a hold, trigger release
            if (isHolding) {
                gestureIndicator.textContent = 'release';
                trigger('button_release');
                setTimeout(() => { gestureIndicator.textContent = ''; }, 500);
                isHolding = false;
                return;
            }

            // Not a hold, count as click
            if (pressDuration < HOLD_THRESHOLD) {
                clickCount++;

                if (clickCount === 1) {
                    // Start timer for double-click detection
                    clickTimer = setTimeout(() => {
                        // Single click
                        gestureIndicator.textContent = 'click';
                        trigger('button_click');
                        setTimeout(() => { gestureIndicator.textContent = ''; }, 500);
                        clickCount = 0;
                    }, DOUBLE_CLICK_WINDOW);
                } else if (clickCount === 2) {
                    // Double click detected
                    clearTimeout(clickTimer);
                    gestureIndicator.textContent = 'double click';
                    trigger('button_double_click');
                    setTimeout(() => { gestureIndicator.textContent = ''; }, 500);
                    clickCount = 0;
                }
            }
        }

        // Load config first, then initial state
        fetchConfig().then(() => fetchState());

        // Enter key to send
        inputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendCommand();
        });

        async function fetchConfig() {
            try {
                const res = await fetch('/api/config');
                const data = await res.json();
                if (data.success && data.representation_version) {
                    ExpressionEvaluator.setVersion(data.representation_version);
                }
                ExpressionEvaluator.setDataStore(sharedStateData);
                if (data.success && data.vision) {
                    visionConfig = data.vision;
                    visionLoopIntervalMs = Math.max(1000, Number(visionConfig.interval_ms || 2000));
                    if (!visionConfig.enabled) {
                        visionStartBtn.disabled = true;
                        visionStopBtn.disabled = true;
                        visionStatus.textContent = 'Vision disabled in server config';
                    } else {
                        visionStatus.textContent = `Vision ready (${visionConfig.mode || 'polling'})`;
                    }
                }
                if (data.success && data.audio) {
                    audioConfig = data.audio;
                }
                if (data.success && data.volume) {
                    volumeConfig = data.volume;
                }
            } catch (e) {
                console.error('Failed to fetch config:', e);
            }
        }

        function updateLight(state) {
            if (!state) return;

            hydrateStateDataFromState(state);

            // Stop any existing animation
            stopAnimation();

            // Reset evaluator for new state
            ExpressionEvaluator.reset();

            // Store current state
            currentState = state;
            stateNameEl.textContent = state.name || state.state_name || 'unknown';

            const wantsVision = Boolean(state.vision_reactive && state.vision_reactive.enabled);
            const wantsAudio = Boolean(state.audio_reactive && state.audio_reactive.enabled);
            const wantsVolume = Boolean(state.volume_reactive && state.volume_reactive.enabled);
            if (visionConfig.enabled && wantsVision && !visionSessionId) {
                visionStatus.textContent = 'State has vision watcher (camera not started)';
            } else if (visionSessionId && !wantsVision) {
                visionStatus.textContent = 'Camera running (no active state watcher)';
            }

            // Keep mic listeners available for both state-level and rule-level watchers.
            if (audioConfig.enabled || volumeConfig.enabled) {
                ensureMicListeners();
            } else {
                stopMicListeners();
            }

            // Check if this is an animated state
            if (ExpressionEvaluator.isAnimated(state)) {
                startAnimation(state);
            } else {
                // Static state - render once
                const prev = [currentColor.r, currentColor.g, currentColor.b];
                const result = ExpressionEvaluator.render(state, prev, 0);
                setLightColor(result.rgb[0], result.rgb[1], result.rgb[2]);
            }
        }

        function setLightColor(r, g, b) {
            currentColor = { r, g, b };
            lightEl.style.background = `rgb(${r}, ${g}, ${b})`;

            // Glow effect based on brightness
            const brightness = (r + g + b) / 3;
            const glowIntensity = Math.max(20, brightness / 255 * 80);
            lightEl.style.boxShadow = `0 0 ${glowIntensity}px rgba(${r}, ${g}, ${b}, 0.7)`;
        }

        function startAnimation(state) {
            animationFrame = 0;
            animationStartTime = performance.now();

            function animate() {
                const elapsed_ms = performance.now() - animationStartTime;
                const prev = [currentColor.r, currentColor.g, currentColor.b];
                const result = ExpressionEvaluator.render(state, prev, elapsed_ms);

                setLightColor(result.rgb[0], result.rgb[1], result.rgb[2]);
                animationFrame++;

                // Schedule next frame based on nextMs from render
                // nextMs > 0: continue animation
                // nextMs = null: static, stop animation
                // nextMs = 0: state complete, trigger transition
                if (result.nextMs && result.nextMs > 0) {
                    animationId = setTimeout(animate, result.nextMs);
                } else if (result.nextMs === null) {
                    // Static state, no more frames needed
                    stopAnimation();
                } else if (result.nextMs === 0) {
                    // State complete - trigger backend transition
                    stopAnimation();
                    triggerStateComplete();
                }
            }

            animate();
        }

        async function triggerStateComplete() {
            console.log('State complete - triggering transition');
            try {
                const res = await fetch('/api/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event: 'state_complete' })
                });
                const data = await res.json();
                if (data.success) {
                    updateLight(data.state);
                    if (detailsOpen) fetchDetails();
                }
            } catch (e) {
                console.error('Failed to trigger state_complete:', e);
            }
        }

        function stopAnimation() {
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        }

        async function fetchState() {
            try {
                const res = await fetch('/api/state');
                const data = await res.json();
                if (data.success) {
                    updateLight(data.state);
                    lastStateName = data.state?.name;
                }
            } catch (e) {
                console.error('Failed to fetch state:', e);
            }
        }

        async function sendCommand() {
            const text = inputEl.value.trim();
            if (!text) return;

            if (!currentUserId) {
                showUserModal();
                return;
            }

            setLoading(true);
            responseEl.className = 'response';

            try {
                const res = await fetch('/api/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text, user_id: currentUserId })
                });
                const data = await res.json();

                if (data.success) {
                    responseEl.className = 'response success';
                    responseTextEl.textContent = data.message || 'Command executed successfully.';
                    updateLight(data.state);
                    lastStateName = data.state?.name;
                    startStatePolling(); // Start polling for timer changes

                    if (data.timing) {
                        timingEl.textContent = `Took ${data.timing.total_ms?.toFixed(0) || '?'}ms`;
                    }

                    if (data.tool_calls && data.tool_calls.length > 0) {
                        toolsEl.textContent = `Tools: ${data.tool_calls.map(t => t.name).join(', ')}`;
                    } else {
                        toolsEl.textContent = '';
                    }

                    // Show quick feedback buttons
                    if (data.session_id) {
                        showQuickFeedback(data.session_id);
                    } else {
                        hideQuickFeedback();
                    }

                    // Render agent steps
                    renderAgentSteps(data.agent_steps);

                    // Show feedback box if we have a session_id
                    if (data.session_id) {
                        showFeedback(data.session_id);
                    } else {
                        closeFeedback();
                    }

                    // Refresh details panel if open
                    if (detailsOpen) fetchDetails();
                } else {
                    responseEl.className = 'response error';
                    responseTextEl.textContent = data.error || 'Command failed.';
                    timingEl.textContent = '';
                    toolsEl.textContent = '';
                    agentStepsPanel.style.display = 'none';
                    hideQuickFeedback();
                    closeFeedback();
                }
            } catch (e) {
                responseEl.className = 'response error';
                responseTextEl.textContent = `Error: ${e.message}`;
                timingEl.textContent = '';
                toolsEl.textContent = '';
                agentStepsPanel.style.display = 'none';
                hideQuickFeedback();
                closeFeedback();
            } finally {
                setLoading(false);
                inputEl.value = '';
            }
        }

        async function trigger(event) {
            try {
                const res = await fetch('/api/trigger', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ event, user_id: currentUserId || 'anonymous' })
                });
                const data = await res.json();

                if (data.success) {
                    updateLight(data.state);
                    if (detailsOpen) fetchDetails();
                }
            } catch (e) {
                console.error('Trigger failed:', e);
            }
        }

        async function resetSM() {
            if (!confirm('Reset all states and rules? This cannot be undone.')) {
                return;
            }

            try {
                const res = await fetch('/api/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: currentUserId })
                });
                const data = await res.json();

                if (data.success) {
                    updateLight(data.state);
                    responseTextEl.textContent = 'State machine reset.';
                    responseEl.className = 'response success';
                    timingEl.textContent = '';
                    toolsEl.textContent = '';
                    agentStepsPanel.style.display = 'none';
                    if (detailsOpen) fetchDetails();
                }
            } catch (e) {
                responseEl.className = 'response error';
                responseTextEl.textContent = `Error: ${e.message}`;
            }
        }

        function setLoading(loading) {
            loadingEl.style.display = loading ? 'block' : 'none';
            responseTextEl.style.display = loading ? 'none' : 'block';
            sendBtn.disabled = loading;
            inputEl.disabled = loading;
        }

        // Details panel
        const detailsContent = document.getElementById('detailsContent');
        const detailsToggle = document.getElementById('detailsToggle');
        const statesList = document.getElementById('statesList');
        const rulesList = document.getElementById('rulesList');

        function toggleDetails() {
            detailsOpen = !detailsOpen;
            detailsContent.classList.toggle('open', detailsOpen);
            detailsToggle.textContent = detailsOpen ? 'â–² Hide' : 'â–¼ Show';
            if (detailsOpen) {
                fetchDetails();
            }
        }

        async function fetchDetails() {
            try {
                const res = await fetch('/api/details');
                const data = await res.json();
                if (data.success) {
                    renderStates(data.states, data.current_state);
                    renderRules(data.rules);
                }
            } catch (e) {
                console.error('Failed to fetch details:', e);
            }
        }

        function renderStates(states, currentState) {
            if (!states || states.length === 0) {
                statesList.innerHTML = '<div class="empty-message">No custom states defined</div>';
                return;
            }

            statesList.innerHTML = states.map(s => {
                const isCurrent = s.name === currentState;
                const r = typeof s.r === 'number' ? s.r : 128;
                const g = typeof s.g === 'number' ? s.g : 128;
                const b = typeof s.b === 'number' ? s.b : 128;

                let params = [];
                if (s.speed) params.push(`speed: ${s.speed}ms`);
                if (s.duration_ms) params.push(`duration: ${s.duration_ms}ms â†’ ${s.then}`);
                if (typeof s.r === 'string') params.push('animated');

                return `
                    <div class="state-item ${isCurrent ? 'current' : ''}">
                        <span class="state-color" style="background: rgb(${r}, ${g}, ${b})"></span>
                        <span class="state-name">${s.name}</span>
                        ${isCurrent ? ' (current)' : ''}
                        ${params.length ? `<div class="state-params">${params.join(' Â· ')}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function renderRules(rules) {
            if (!rules || rules.length === 0) {
                rulesList.innerHTML = '<div class="empty-message">No rules defined</div>';
                return;
            }

            rulesList.innerHTML = rules.map(r => {
                let extra = [];
                if (r.condition) extra.push(`if: ${r.condition}`);
                if (r.action) extra.push(`do: ${r.action}`);
                if (r.pipeline) extra.push(`pipeline: ${r.pipeline}`);
                const audioTrigger = r?.trigger_config?.audio;
                if (audioTrigger && audioTrigger.enabled) {
                    const audioEvent = audioTrigger.event || r.on || 'audio_event';
                    const interval = Number(audioTrigger.interval_ms || audioConfig.interval_ms || 3000);
                    const cooldown = Number(audioTrigger.cooldown_ms || audioConfig.cooldown_ms || 1500);
                    extra.push(`audio watcher: ${audioEvent} Â· ${interval}ms/${cooldown}ms`);
                }

                return `
                    <div class="rule-item">
                        <span class="state-name">${r.from}</span>
                        <span class="rule-arrow"> â†’ </span>
                        <span class="rule-trigger">[${r.on}]</span>
                        <span class="rule-arrow"> â†’ </span>
                        <span class="state-name">${r.to}</span>
                        ${extra.length ? `<div class="rule-condition">${extra.join(' Â· ')}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // Agent Steps Panel
        function toggleAgentSteps() {
            agentStepsOpen = !agentStepsOpen;
            agentStepsContent.classList.toggle('open', agentStepsOpen);
            agentStepsToggle.textContent = agentStepsOpen ? 'â–² Hide' : 'â–¼ Show';
        }

        function renderAgentSteps(steps) {
            if (!steps || steps.length === 0) {
                agentStepsPanel.style.display = 'none';
                return;
            }

            agentStepsPanel.style.display = 'block';
            agentStepsCount.textContent = `(${steps.length})`;

            const icons = {
                'thinking': 'ðŸ’­',
                'tool_call': 'ðŸ”§',
                'tool_result': 'âœ…',
                'api_timing': 'â±ï¸',
                'done': 'ðŸŽ‰'
            };

            agentStepsList.innerHTML = steps.map(step => {
                const icon = icons[step.step_type] || 'â€¢';
                const timing = step.duration_ms ? `${step.duration_ms.toFixed(0)}ms` : '';

                let content = '';
                if (step.step_type === 'thinking' && step.content) {
                    content = escapeHtml(step.content);
                } else if (step.step_type === 'tool_call') {
                    const toolInputJson = escapeHtml(JSON.stringify(step.tool_input, null, 2));
                    const watcherSnippets = collectWatcherSnippets(step);
                    const watcherText = watcherSnippets.length > 0
                        ? `\n\n[watcher code]\n${escapeHtml(watcherSnippets.join('\n\n'))}`
                        : '';
                    content = `<span class="step-tool-name">${escapeHtml(step.tool_name)}</span>\n${toolInputJson}${watcherText}`;
                } else if (step.step_type === 'tool_result') {
                    content = `<span class="step-tool-name">${escapeHtml(step.tool_name)}</span>\n${escapeHtml(JSON.stringify(step.tool_result, null, 2))}`;
                } else if (step.step_type === 'api_timing' && step.content) {
                    content = escapeHtml(step.content);
                } else if (step.step_type === 'done' && step.content) {
                    content = escapeHtml(step.content);
                }

                return `
                    <div class="agent-step ${step.step_type}">
                        <div class="step-header">
                            <span class="step-icon">${icon}</span>
                            <span class="step-turn">Turn ${step.turn}</span>
                            <span class="step-type ${step.step_type}">${step.step_type.replace('_', ' ')}</span>
                            ${timing ? `<span class="step-timing">${timing}</span>` : ''}
                        </div>
                        ${content ? `<div class="step-content">${content}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function collectWatcherSnippets(step) {
            const snippets = [];
            if (!step || step.step_type !== 'tool_call') return snippets;

            const toolName = String(step.tool_name || '').trim().toLowerCase();
            const toolInput = step.tool_input || {};

            if (toolName === 'createstate') {
                const code = typeof toolInput.code === 'string' ? toolInput.code : '';
                const directives = extractVisionDirectivesFromCode(code);
                if (directives.length > 0) {
                    snippets.push(`state watcher (vision.* directives)\n${directives.join('\n')}`);
                }
            }

            if (toolName === 'appendrules') {
                const rules = Array.isArray(toolInput.rules)
                    ? toolInput.rules
                    : (Array.isArray(toolInput) ? toolInput : []);

                rules.forEach((rule, index) => {
                    const visionCfg = rule?.trigger_config?.vision;
                    if (!visionCfg || typeof visionCfg !== 'object') return;
                    const fromState = String(rule?.from ?? '*');
                    const eventName = String(rule?.on ?? 'event');
                    const toState = String(rule?.to ?? '?');
                    snippets.push(
                        `rule watcher #${index + 1} (${fromState} --[${eventName}]--> ${toState})\n${JSON.stringify(visionCfg, null, 2)}`
                    );
                });
            }

            return snippets;
        }

        function extractVisionDirectivesFromCode(code) {
            if (typeof code !== 'string' || code.length === 0) return [];
            const directives = [];
            const lines = code.split(/\r?\n/);
            const pattern = /^\s*(?:#|\/\/)\s*(vision\.[A-Za-z0-9_\.]+)\s*=\s*(.+?)\s*$/;

            for (const line of lines) {
                const match = line.match(pattern);
                if (!match) continue;
                directives.push(`${match[1]} = ${match[2]}`);
            }
            return directives;
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Quick feedback elements
        const quickFeedback = document.getElementById('quickFeedback');
        const feedbackGood = document.getElementById('feedbackGood');
        const feedbackBad = document.getElementById('feedbackBad');
        const feedbackSubmittedMsg = document.getElementById('feedbackSubmittedMsg');
        let quickFeedbackSessionId = null;

        function showQuickFeedback(sessionId) {
            quickFeedbackSessionId = sessionId;
            quickFeedback.style.display = 'flex';
            feedbackGood.disabled = false;
            feedbackBad.disabled = false;
            feedbackGood.classList.remove('selected');
            feedbackBad.classList.remove('selected');
            feedbackSubmittedMsg.style.display = 'none';
        }

        function hideQuickFeedback() {
            quickFeedback.style.display = 'none';
            quickFeedbackSessionId = null;
        }

        async function submitQuickFeedback(isGood) {
            if (!quickFeedbackSessionId) return;

            // Disable both buttons immediately
            feedbackGood.disabled = true;
            feedbackBad.disabled = true;

            // Show selected state
            if (isGood) {
                feedbackGood.classList.add('selected');
            } else {
                feedbackBad.classList.add('selected');
            }

            // Show thanks message
            feedbackSubmittedMsg.style.display = 'inline';

            // Send to backend
            try {
                await fetch('/api/quick-feedback', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: quickFeedbackSessionId,
                        worked: isGood
                    })
                });
            } catch (e) {
                console.error('Failed to submit quick feedback:', e);
            }
        }

        function currentStateWantsAudio() {
            // Audio rule watchers can be active even when the current state does not
            // define audio_reactive, so keep audio processing available when globally enabled.
            return Boolean(audioConfig?.enabled);
        }

        function currentStateWantsVolume() {
            return Boolean(currentState?.volume_reactive?.enabled);
        }

        function computeMicMetrics() {
            if (!micAnalyser || !micDataArray) {
                return { rms: 0, peak: 0, level: 0 };
            }
            micAnalyser.getByteTimeDomainData(micDataArray);
            let sumSq = 0;
            let peak = 0;
            for (let i = 0; i < micDataArray.length; i++) {
                const centered = (micDataArray[i] - 128) / 128;
                const abs = Math.abs(centered);
                sumSq += centered * centered;
                if (abs > peak) peak = abs;
            }
            const rms = Math.sqrt(sumSq / micDataArray.length);
            const level = Math.max(rms, peak);
            return { rms, peak, level };
        }

        async function ensureMicListeners() {
            if (audioListenerRunning || volumeListenerRunning) {
                return;
            }
            audioListenerRunning = true;
            volumeListenerRunning = true;
            try {
                if (!micStream) {
                    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                }

                if (!micAudioContext) {
                    micAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (!micSourceNode) {
                    micSourceNode = micAudioContext.createMediaStreamSource(micStream);
                }
                if (!micAnalyser) {
                    micAnalyser = micAudioContext.createAnalyser();
                    micAnalyser.fftSize = 2048;
                    micSourceNode.connect(micAnalyser);
                    micDataArray = new Uint8Array(micAnalyser.fftSize);
                }

                if (!audioSessionId && audioConfig.enabled) {
                    await startAudioSession();
                }
                if (!volumeSessionId && volumeConfig.enabled) {
                    const res = await fetch('/api/volume/session/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: currentUserId || 'anonymous' }),
                    });
                    const data = await res.json();
                    if (data.success) {
                        volumeSessionId = data.session_id;
                    }
                }

                startVolumeLoop();
                startAudioLoop();
            } catch (e) {
                console.error('Failed to start mic listeners:', e);
                audioListenerRunning = false;
                volumeListenerRunning = false;
            }
        }

        async function startAudioSession() {
            const res = await fetch('/api/audio/session/start', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: currentUserId || 'anonymous' }),
            });
            const data = await res.json();
            if (data.success) {
                audioSessionId = data.session_id;
                return true;
            }
            return false;
        }

        async function stopMicListeners() {
            audioListenerRunning = false;
            volumeListenerRunning = false;

            if (audioLoopId) {
                clearInterval(audioLoopId);
                audioLoopId = null;
            }
            if (volumeLoopId) {
                clearInterval(volumeLoopId);
                volumeLoopId = null;
            }

            if (audioSessionId) {
                try {
                    await fetch('/api/audio/session/stop', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ session_id: audioSessionId }),
                    });
                } catch (e) {
                    console.error('Failed to stop audio session:', e);
                }
            }
            if (volumeSessionId) {
                try {
                    await fetch('/api/volume/session/stop', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ session_id: volumeSessionId }),
                    });
                } catch (e) {
                    console.error('Failed to stop volume session:', e);
                }
            }

            audioSessionId = null;
            volumeSessionId = null;
            audioChunkParts = [];
            audioSpeechActive = false;
            audioChunkStartedAtMs = 0;

            if (micRecognition) {
                try { micRecognition.onend = null; } catch (e) {}
                try { micRecognition.stop(); } catch (e) {}
            }
            micRecognition = null;

            if (micSourceNode) {
                try { micSourceNode.disconnect(); } catch (e) {}
            }
            micSourceNode = null;
            micAnalyser = null;
            micDataArray = null;

            if (micAudioContext) {
                try { await micAudioContext.close(); } catch (e) {}
            }
            micAudioContext = null;
            if (micStream) {
                micStream.getTracks().forEach(track => track.stop());
            }
            micStream = null;
        }

        function startVolumeLoop() {
            if (volumeLoopId) return;
            const intervalMs = Math.max(30, Number(volumeConfig.interval_ms || 80));
            volumeLoopId = setInterval(async () => {
                if (!volumeListenerRunning || !volumeSessionId || !currentStateWantsVolume()) return;
                const metrics = computeMicMetrics();
                latestMicLevel = metrics.level;
                try {
                    const res = await fetch('/api/volume/frame', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: volumeSessionId,
                            level: metrics.level,
                            rms: metrics.rms,
                            peak: metrics.peak,
                            speaking: metrics.level > 0.02,
                        }),
                    });
                    const data = await res.json();
                    if (data.success && data.volume) {
                        sharedStateData['volume'] = data.volume;
                    }
                    if (data.success && data.state) {
                        updateLight(data.state);
                    }
                } catch (e) {
                    console.error('volume loop error:', e);
                }
            }, intervalMs);
        }

        function startAudioLoop() {
            if (audioLoopId) return;

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition = null;
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                recognition.onresult = (event) => {
                    if (!currentStateWantsAudio()) return;
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        transcript += event.results[i][0].transcript || '';
                    }
                    transcript = transcript.trim();
                    if (!transcript) return;
                    if (!audioSpeechActive) {
                        audioSpeechActive = true;
                        audioChunkStartedAtMs = Date.now();
                    }
                    audioChunkParts.push(transcript);
                };
                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                };
                recognition.onend = () => {
                    if (audioListenerRunning && currentStateWantsAudio()) {
                        try { recognition.start(); } catch (e) {}
                    }
                };
                try { recognition.start(); } catch (e) {}
            }
            micRecognition = recognition;

            audioLoopId = setInterval(async () => {
                if (!audioListenerRunning || !audioSessionId || !currentStateWantsAudio()) return;
                const now = Date.now();
                const elapsed = audioSpeechActive ? (now - audioChunkStartedAtMs) : 0;
                const shouldSendChunk = audioChunkParts.length > 0 && elapsed >= 3000;
                const allowFallback = Boolean(audioConfig.allow_fallback_transcript);
                const shouldSendFallback = allowFallback && audioChunkParts.length === 0 && latestMicLevel > 0.03 && (now - audioLastSentAtMs) >= Math.max(1000, Number(audioConfig.interval_ms || 3000));
                if (!shouldSendChunk && !shouldSendFallback) return;

                let transcript = '';
                if (shouldSendChunk) {
                    transcript = audioChunkParts.join(' ').trim();
                    audioChunkParts = [];
                    audioSpeechActive = false;
                    audioChunkStartedAtMs = 0;
                } else {
                    transcript = 'ambient audio detected';
                }
                if (!transcript) return;

                audioLastSentAtMs = now;
                try {
                    console.log('[audio transcript]', {
                        session_id: audioSessionId,
                        transcript,
                        source: shouldSendChunk ? 'speech_recognition' : 'fallback_meter',
                        level: latestMicLevel,
                    });

                    const res = await fetch('/api/audio/chunk', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: audioSessionId,
                            transcript,
                            chunk_meta: {
                                level: latestMicLevel,
                                chunk_ms: shouldSendChunk ? 3000 : 0,
                                source: shouldSendChunk ? 'speech_recognition' : 'fallback_meter',
                            },
                        }),
                    });

                    if (res.status === 404) {
                        audioSessionId = null;
                        await startAudioSession();
                        return;
                    }

                    const data = await res.json();
                    if (data.success && data.audio) {
                        sharedStateData['audio'] = data.audio;
                    }
                    if (data.success && data.state) {
                        updateLight(data.state);
                    }
                } catch (e) {
                    console.error('audio loop error:', e);
                }
            }, 250);
        }

        async function startCameraVision() {
            if (!visionConfig.enabled) {
                visionStatus.textContent = 'Vision disabled in server config';
                return;
            }

            if (visionSessionId) {
                visionStatus.textContent = 'Vision already running';
                return;
            }

            try {
                visionStatus.textContent = 'Requesting camera access...';
                visionStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640, max: 640 },
                        height: { ideal: 360, max: 360 },
                        facingMode: 'user'
                    },
                    audio: false
                });
                visionVideo.srcObject = visionStream;
                visionVideo.style.display = 'block';

                await new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => reject(new Error('Camera did not become ready in time')), 4000);
                    visionVideo.onloadedmetadata = () => {
                        clearTimeout(timeoutId);
                        resolve();
                    };
                });
                await visionVideo.play();

                const sessionRes = await fetch('/api/vision/session/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_id: currentUserId || 'anonymous' })
                });
                const sessionData = await sessionRes.json();
                if (!sessionData.success) {
                    throw new Error(sessionData.error || 'Failed to start vision session');
                }

                visionSessionId = sessionData.session_id;
                visionStartBtn.disabled = true;
                visionStopBtn.disabled = false;
                visionFrameInFlight = false;
                visionDroppedFrames = 0;
                visionLoopIntervalMs = Math.max(1000, Number(visionConfig.interval_ms || 2000));
                visionStatus.textContent = `Vision running (${visionConfig.mode || 'polling'}, ${visionVideo.videoWidth}x${visionVideo.videoHeight})`;
                setVisionDebug({
                    state: 'Vision State: active',
                    engine: lastVlmEngineText,
                    countdown: 'Next capture in: now',
                    description: lastVlmDescriptionText,
                    data: lastVlmDataText,
                    timing: 'Timing: -'
                });

                scheduleVisionLoop(0);
            } catch (e) {
                console.error('Failed to start camera vision:', e);
                visionStatus.textContent = `Vision start failed: ${e.message}`;
                setVisionDebug({
                    state: 'Vision State: start failed',
                    countdown: 'Next capture in: -',
                    description: `Description: ${e.message}`,
                    timing: 'Timing: -'
                });
                if (visionStream) {
                    visionStream.getTracks().forEach(track => track.stop());
                    visionStream = null;
                }
            }
        }

        async function stopCameraVision() {
            if (visionLoopId) {
                clearTimeout(visionLoopId);
                visionLoopId = null;
            }

            if (visionStream) {
                visionStream.getTracks().forEach(track => track.stop());
                visionStream = null;
            }
            if (visionVideo) {
                visionVideo.srcObject = null;
                visionVideo.style.display = 'none';
            }

            if (visionSessionId) {
                try {
                    await fetch('/api/vision/session/stop', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ session_id: visionSessionId })
                    });
                } catch (e) {
                    console.error('Failed to stop vision session:', e);
                }
            }

            visionSessionId = null;
            visionFrameInFlight = false;
            visionDroppedFrames = 0;
            visionNextCaptureAtMs = 0;
            stopVisionCountdownTicker();
            visionStartBtn.disabled = !visionConfig.enabled;
            visionStopBtn.disabled = true;
            visionStatus.textContent = visionConfig.enabled ? 'Vision idle' : 'Vision disabled in server config';
            setVisionDebug({
                state: 'Vision State: idle',
                engine: lastVlmEngineText,
                countdown: 'Next capture in: -',
                description: lastVlmDescriptionText,
                data: lastVlmDataText,
                timing: 'Timing: -'
            });
        }

        async function sendVisionFrame() {
            if (!visionSessionId || !visionVideo || visionVideo.readyState < 2) {
                return;
            }
            if (visionFrameInFlight) {
                visionDroppedFrames += 1;
                return;
            }

            visionFrameInFlight = true;
            try {
                setVisionDebug({
                    state: 'Vision State: capturing',
                    engine: visionDebugEngine ? visionDebugEngine.textContent : lastVlmEngineText,
                    countdown: 'Next capture in: capturing now',
                    description: visionDebugDescription ? visionDebugDescription.textContent : 'Description: -',
                    data: visionDebugData ? visionDebugData.textContent : 'Data: -',
                    timing: visionDebugTiming ? visionDebugTiming.textContent : 'Timing: -'
                });

                const clientStartMs = performance.now();
                const srcWidth = visionVideo.videoWidth || 640;
                const srcHeight = visionVideo.videoHeight || 480;
                const scale = Math.min(1, VISION_SEND_MAX_WIDTH / srcWidth);
                const frameWidth = Math.max(320, Math.round(srcWidth * scale));
                const frameHeight = Math.max(240, Math.round(srcHeight * scale));
                if (visionCanvas.width !== frameWidth || visionCanvas.height !== frameHeight) {
                    visionCanvas.width = frameWidth;
                    visionCanvas.height = frameHeight;
                }

                const ctx = visionCanvas.getContext('2d');
                ctx.drawImage(visionVideo, 0, 0, visionCanvas.width, visionCanvas.height);
                const imageDataUrl = visionCanvas.toDataURL('image/jpeg', 0.6);  // Lower quality = faster transfer

                const res = await fetch('/api/vision/frame', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: visionSessionId,
                        image: imageDataUrl
                    })
                });

                const data = await res.json();
                const clientRoundTripMs = Math.round(performance.now() - clientStartMs);

                // Debug: log the full response
                console.log('[vision] frame response:', data);

                // New simplified vision: write raw vision output to 'vision' key
                if (data.vision && typeof data.vision === 'object') {
                    sharedStateData['vision'] = data.vision;
                    console.log('[vision] wrote to sharedStateData.vision:', data.vision);
                } else {
                    console.log('[vision] no data.vision in response');
                }

                // Legacy support for mapped_data (can be removed later)
                const mappedData = Array.isArray(data?.vision_debug?.mapped_data) ? data.vision_debug.mapped_data : [];
                applyMappedDataToStore(mappedData);
                if (data.success && data.state) {
                    updateLight(data.state);
                }
                updateVisionLoopIntervalFromWatchers(data.watchers);

                if (data.success && data.processed) {
                    if (Array.isArray(data.detections) && data.detections.length > 0) {
                        const sortedDetections = [...data.detections].sort((a, b) => Number(b.confidence || 0) - Number(a.confidence || 0));
                        const top = sortedDetections.find(item => !item.error) || sortedDetections[0];
                        if (top.error) {
                            visionStatus.textContent = 'Vision frame error: invalid image payload';
                            setVisionDebug({
                                state: 'Vision State: error',
                                engine: 'Engine: -',
                                description: `Description: ${top.error}`,
                                timing: `Timing: client ${clientRoundTripMs}ms | dropped ${visionDroppedFrames}`
                            });
                        } else {
                            const backendMs = Number(data?.vision_debug?.backend_latency_ms || 0);
                            const watcherMs = Number(top.latency_ms || 0);
                            const engine = top.engine || 'unknown';
                            const reason = top.reason || 'No description';
                            const mappedSkips = Array.isArray(data?.vision_debug?.mapped_data_skips) ? data.vision_debug.mapped_data_skips : [];
                            const mappingDiagnostics = Array.isArray(data?.vision_debug?.mapping_diagnostics) ? data.vision_debug.mapping_diagnostics : [];
                            const watcherFields = (top && typeof top.fields === 'object' && top.fields !== null) ? top.fields : {};
                            const watcherFieldEntries = Object.entries(watcherFields);
                            if (mappingDiagnostics.length > 0) {
                                console.log('[vision] mapping diagnostics', mappingDiagnostics);
                            }
                            const mappedText = mappedData.length > 0
                                ? mappedData.map(item => `${item.key}=${formatVisionValue(item.value)}`).join(' | ')
                                : '-';
                            const watcherText = watcherFieldEntries.length > 0
                                ? watcherFieldEntries.map(([key, value]) => `${key}=${formatVisionValue(value)}`).join(' | ')
                                : '-';
                            const skipText = mappedSkips.length > 0
                                ? mappedSkips.map(item => `${item.watcher}: ${item.reason}${item.field ? ` [expected=${item.field}]` : ''}${Array.isArray(item.available_fields) && item.available_fields.length ? ` [available=${item.available_fields.join(',')}]` : ''}`).join(' | ')
                                : '';
                            const dataText = skipText
                                ? `Data (getData): ${mappedText} | Watcher output: ${watcherText} | Mapping: ${skipText}`
                                : `Data (getData): ${mappedText} | Watcher output: ${watcherText}`;

                            const stateText = `Vision State: ${top.detected ? 'detection active' : 'waiting for detection'}`;
                            const engineText = `Engine: ${engine}`;
                            const descriptionText = `Description: ${reason}`;
                            const timingText = `Timing: client ${clientRoundTripMs}ms | backend ${backendMs}ms | watcher ${watcherMs}ms | dropped ${visionDroppedFrames}`;
                            rememberLatestVlm({ state: stateText, engine: engineText, description: descriptionText, data: dataText, timing: timingText });
                            setVisionDebug({
                                state: stateText,
                                engine: engineText,
                                description: descriptionText,
                                data: dataText,
                                timing: timingText
                            });

                            if (data.emitted_events && data.emitted_events.length > 0) {
                                visionStatus.textContent = `Vision event: ${data.emitted_events.join(', ')}`;
                            } else {
                                visionStatus.textContent = `Vision: ${top.detected ? 'detection active' : 'waiting for detection'}`;
                            }
                        }
                    } else if (data.emitted_events && data.emitted_events.length > 0) {
                        visionStatus.textContent = `Vision event: ${data.emitted_events.join(', ')}`;
                    }
                } else if (data.success && !data.processed && data.reason) {
                    const backendMs = Number(data?.vision_debug?.backend_latency_ms || 0);
                    visionStatus.textContent = `Vision idle: ${data.reason}`;
                    setVisionDebug({
                        state: `Vision State: ${data.reason}`,
                        engine: lastVlmEngineText,
                        description: lastVlmDescriptionText,
                        data: lastVlmDataText,
                        timing: `Timing: backend ${backendMs}ms | dropped ${visionDroppedFrames} | no new inference`
                    });
                }
            } catch (e) {
                console.error('Vision frame send failed:', e);
                visionStatus.textContent = `Vision send failed: ${e.message}`;
                setVisionDebug({
                    state: 'Vision State: send failed',
                    engine: 'Engine: -',
                    description: `Description: ${e.message}`,
                    timing: 'Timing: -'
                });
            } finally {
                visionFrameInFlight = false;
            }
        }

        window.addEventListener('beforeunload', () => {
            if (visionLoopId) {
                clearTimeout(visionLoopId);
            }
            stopVisionCountdownTicker();
            if (visionStream) {
                visionStream.getTracks().forEach(track => track.stop());
            }
            stopMicListeners();
        });
    </script>
</body>
</html>
